const OpenAI = require("openai");
const TelegramBot = require("node-telegram-bot-api");
const { MongoClient } = require("mongodb");
const axios = require("axios");
const moment = require("moment-timezone");
require("dotenv").config();

// OpenAI Configuration
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

// MongoDB Configuration
const mongoUri = process.env.MONGO_URI;
const client = new MongoClient(mongoUri);
let db;

// MongoDB Connection
async function connectToMongoDB() {
  try {
    await client.connect();
    db = client.db("astrologyBotDB");
    console.log("‚úÖ Connected to MongoDB");
  } catch (error) {
    console.error("‚ùå MongoDB Connection Error:", error.message);
    setTimeout(connectToMongoDB, 5000); // Retry connection
  }
}

// Utility Functions
async function saveUserData(userId, data) {
  try {
    await db.collection("users").updateOne({ userId }, { $set: { ...data } }, { upsert: true });
  } catch (error) {
    console.error("‚ùå Error saving user data:", error.message);
  }
}

async function getUserData(userId) {
  try {
    return await db.collection("users").findOne({ userId });
  } catch (error) {
    console.error("‚ùå Error fetching user data:", error.message);
    return null;
  }
}

async function generateResponse(prompt, userData, language) {
  const systemPrompt =
  language === "RU"
    ? "–¢—ã —á—É—Ç–∫–∏–π –ø—Å–∏—Ö–æ–ª–æ–≥ –∏ –æ–ø—ã—Ç–Ω—ã–π –∞—Å—Ç—Ä–æ–ª–æ–≥. –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –ø–æ–º–æ–≥–∞—è —Å–ø—Ä–∞–≤–ª—è—Ç—å—Å—è —Å —Ç—Ä–µ–≤–æ–≥–æ–π, –±–æ–ª—å—é –∏ –∂–∏–∑–Ω–µ–Ω–Ω—ã–º–∏ —Ç—Ä—É–¥–Ω–æ—Å—Ç—è–º–∏. –î–∞–π –º—É–¥—Ä—ã–µ —Å–æ–≤–µ—Ç—ã –∏ –ø—Ä–µ–¥—Å–∫–∞–∂–∏ –≤–∞–∂–Ω—ã–µ –º–æ–º–µ–Ω—Ç—ã –¥–ª—è –∏—Ö —Ä–æ—Å—Ç–∞ –∏ –∏—Å—Ü–µ–ª–µ–Ω–∏—è."
    : "You are a compassionate psychologist and experienced astrologer. Support the user in overcoming anxiety, pain, and life challenges. Offer wise guidance and predict key moments for their growth and healing.";


  const context = userData
    ? `User info: Name: ${userData.name}, Birthday: ${userData.birthday}, Birthplace: ${userData.birthplace}.`
    : "No user details provided.";

  const fullPrompt = `${context}\n\n${prompt}`;
  const response = await openai.chat.completions.create({
    model: "gpt-4",
    messages: [
      { role: "system", content: systemPrompt },
      { role: "user", content: fullPrompt },
    ],
    temperature: 1.0,
  });
  return response.choices[0]?.message?.content || "No response generated.";
}

async function getTimezoneFromLocation(lat, lng) {
  const apiKey = process.env.GOOGLE_TIMEZONE_API_KEY;
  const timestamp = Math.floor(new Date().getTime() / 1000);

  const response = await axios.get(
    `https://maps.googleapis.com/maps/api/timezone/json?location=${lat},${lng}&timestamp=${timestamp}&key=${apiKey}`
  );

  if (response.data.status === "OK") {
    return response.data.timeZoneId;
  } else {
    throw new Error("Invalid response from Timezone API");
  }
}

// Initialize Telegram Bot
async function startBot() {
  const bot = new TelegramBot(process.env.TELEGRAM_BOT_TOKEN, { polling: true });
  console.log("ü§ñ Bot is running in polling mode...");

  // Command Handlers
  bot.onText(/\/start/, (msg) => {
    bot.sendMessage(msg.chat.id, "Choose your language / –í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫:", {
      reply_markup: {
        inline_keyboard: [
          [{ text: "English", callback_data: "LANG_ENG" }],
          [{ text: "–†—É—Å—Å–∫–∏–π", callback_data: "LANG_RU" }],
        ],
      },
    });
  });

  bot.on("callback_query", async (query) => {
    const chatId = query.message.chat.id;
    const language = query.data === "LANG_RU" ? "RU" : "ENG";
    await saveUserData(chatId, { language });
    bot.sendMessage(
      chatId,
      language === "RU"
        ? "–ü—Ä–∏–≤–µ—Ç! –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /help –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∫–æ–º–∞–Ω–¥."
        : "Hello! Use /help to view the available commands."
    );
  });

  bot.onText(/\/help/, async (msg) => {
    const userData = await getUserData(msg.chat.id);
    const language = userData?.language || "ENG";
    const helpText =
      language === "RU"
        ? "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n/setinfo - –í–≤–µ—Å—Ç–∏ –¥–∞–Ω–Ω—ã–µ\n/viewinfo - –ü–æ–∫–∞–∑–∞—Ç—å –¥–∞–Ω–Ω—ã–µ\n/today - –ì–æ—Ä–æ—Å–∫–æ–ø –Ω–∞ —Å–µ–≥–æ–¥–Ω—è\n/tomorrow - –ì–æ—Ä–æ—Å–∫–æ–ø –Ω–∞ –∑–∞–≤—Ç—Ä–∞\n/year - –ì–æ–¥–æ–≤–æ–π –ø—Ä–æ–≥–Ω–æ–∑\n/settimezone - –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å (–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏)\n/settimezone_manual - –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å –≤—Ä—É—á–Ω—É—é"
        : "Available commands:\n/setinfo - Enter your details\n/viewinfo - Show your details\n/today - Today's horoscope\n/tomorrow - Tomorrow's horoscope\n/year - Annual forecast\n/settimezone - Set timezone automatically\n/settimezone_manual - Set timezone manually";

    bot.sendMessage(msg.chat.id, helpText);
  });

  bot.onText(/\/setinfo/, async (msg) => {
    const chatId = msg.chat.id;
    const userLanguage = (await getUserData(chatId))?.language || "ENG";

    bot.sendMessage(
      chatId,
      userLanguage === "RU"
        ? "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –≤–∞—à–∏ –¥–∞–Ω–Ω—ã–µ –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n–ò–º—è, –î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è (–ì–ì–ì–ì-–ú–ú-–î–î), –ú–µ—Å—Ç–æ —Ä–æ–∂–¥–µ–Ω–∏—è"
        : "Please send your details in this format:\nName, Birthday (YYYY-MM-DD), Birthplace"
    );

    bot.once("message", async (response) => {
      if (!response.text.includes(",")) {
        bot.sendMessage(
          chatId,
          userLanguage === "RU"
            ? "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ: –ò–º—è, –î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è (–ì–ì–ì–ì-–ú–ú-–î–î), –ú–µ—Å—Ç–æ —Ä–æ–∂–¥–µ–Ω–∏—è."
            : "‚ùå Invalid format. Please use: Name, Birthday (YYYY-MM-DD), Birthplace."
        );
        return;
      }

      const [name, birthday, birthplace] = response.text.split(",").map((field) => field.trim());
      await saveUserData(chatId, { name, birthday, birthplace, language: userLanguage });

      bot.sendMessage(
        chatId,
        userLanguage === "RU" ? "‚úÖ –í–∞—à–∏ –¥–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã." : "‚úÖ Your details have been saved."
      );
    });
  });
  // View Saved User Info
  bot.onText(/\/viewinfo/, async (msg) => {
    const userData = await getUserData(msg.chat.id);
    const language = userData?.language || "ENG";

    if (userData?.name && userData?.birthday && userData?.birthplace) {
      bot.sendMessage(
        msg.chat.id,
        language === "RU"
          ? `–í–∞—à–∏ –¥–∞–Ω–Ω—ã–µ:\n–ò–º—è: ${userData.name}\n–î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è: ${userData.birthday}\n–ú–µ—Å—Ç–æ —Ä–æ–∂–¥–µ–Ω–∏—è: ${userData.birthplace}`
          : `Your details:\nName: ${userData.name}\nBirthday: ${userData.birthday}\nBirthplace: ${userData.birthplace}`
      );
    } else {
      bot.sendMessage(
        msg.chat.id,
        language === "RU"
          ? "–í—ã –µ—â–µ –Ω–µ –≤–≤–µ–ª–∏ –¥–∞–Ω–Ω—ã–µ. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /setinfo."
          : "You haven't entered any details yet. Use /setinfo."
      );
    }
  });

  // Today's Horoscope
  bot.onText(/\/today/, async (msg) => {
    const userData = await getUserData(msg.chat.id);
    const timezone = userData?.timezone || "UTC";

    const today = moment().tz(timezone).format("YYYY-MM-DD");
    const prompt = `Today's horoscope for ${today} for ${userData?.birthday || "unknown"} in ${
      userData?.birthplace || "unknown"
    }.`;

    const response = await generateResponse(prompt, userData, userData?.language || "ENG");
    bot.sendMessage(msg.chat.id, response);
  });

  // Tomorrow's Horoscope
  bot.onText(/\/tomorrow/, async (msg) => {
    const userData = await getUserData(msg.chat.id);
    const timezone = userData?.timezone || "UTC";

    const tomorrow = moment().tz(timezone).add(1, "days").format("YYYY-MM-DD");
    const prompt = `Tomorrow's horoscope for ${tomorrow} for ${userData?.birthday || "unknown"} in ${
      userData?.birthplace || "unknown"
    }.`;

    const response = await generateResponse(prompt, userData, userData?.language || "ENG");
    bot.sendMessage(msg.chat.id, response);
  });

  // Annual Forecast
  bot.onText(/\/year/, async (msg) => {
    const userData = await getUserData(msg.chat.id);
    const timezone = userData?.timezone || "UTC";

    try {
      if (!moment.tz.zone(timezone)) throw new Error("Invalid timezone.");
      const year = moment().tz(timezone).year();

      const prompt = `Annual forecast for the year ${year} for ${userData?.birthday || "unknown"} in ${
        userData?.birthplace || "unknown"
      }.`;

      const response = await generateResponse(prompt, userData, userData?.language || "ENG");
      bot.sendMessage(msg.chat.id, response);
    } catch (error) {
      bot.sendMessage(
        msg.chat.id,
        "There was an issue with your timezone. Please reset it using /settimezone."
      );
    }
  });

  // Set Timezone Automatically
  bot.onText(/\/settimezone/, async (msg) => {
    const chatId = msg.chat.id;

    bot.sendMessage(
      chatId,
      "Please share your location so I can set your timezone automatically.",
      {
        reply_markup: {
          keyboard: [
            [
              {
                text: "üìç Share Location/–ü–æ–¥–µ–ª–∏—Ç—å—Å—è –≥–µ–æ–ª–æ–∫–∞—Ü–∏–µ–π",
                request_location: true,
              },
            ],
          ],
          resize_keyboard: true,
          one_time_keyboard: true,
        },
      }
    );

    // Listen for location
    bot.once("location", async (response) => {
      try {
        const { latitude, longitude } = response.location;

        const timezone = await getTimezoneFromLocation(latitude, longitude);

        if (timezone) {
          await saveUserData(chatId, { timezone });
          bot.sendMessage(chatId, `‚úÖ Timezone detected and set to "${timezone}".`);
        } else {
          bot.sendMessage(
            chatId,
            "‚ùå Unable to detect timezone. Please try again or set it manually using /settimezone_manual."
          );
        }
      } catch (error) {
        console.error("‚ùå Error detecting timezone:", error.message);
        bot.sendMessage(
          chatId,
          "‚ùå Something went wrong while setting your timezone. Please try again later."
        );
      }
    });
  });

// Set Timezone Manually
bot.onText(/\/settimezone_manual/, async (msg) => {
  bot.sendMessage(
    msg.chat.id,
    "Please provide your timezone manually (e.g., 'America/New_York' or '+3')."
  );

  bot.once("message", async (response) => {
    try {
      const timezone = response.text.trim();

      if (!moment.tz.zone(timezone) && !/^(\+|-)\d{1,2}$/.test(timezone)) {
        bot.sendMessage(msg.chat.id, "‚ùå Invalid timezone format. Try again.");
        return;
      }

      await saveUserData(msg.chat.id, { timezone });
      bot.sendMessage(msg.chat.id, `‚úÖ Your timezone has been set to "${timezone}".`);
    } catch (error) {
      console.error("‚ùå Error saving timezone:", error.message);
      bot.sendMessage(msg.chat.id, "‚ùå Something went wrong. Please try again.");
    }
  });
});

// Random Message Response
bot.on("message", async (msg) => {
  const chatId = msg.chat.id;

  // Skip if msg.text is undefined or starts with "/"
  if (!msg.text || msg.text.startsWith("/")) return;

  const userData = await getUserData(chatId);
  const language = userData?.language || "ENG";
  const timezone = userData?.timezone || "UTC";
  const today = moment().tz(timezone).format("YYYY-MM-DD");

  const fullPrompt =
    language === "RU"
      ? `–í–æ–ø—Ä–æ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: ${msg.text}. –°–µ–≥–æ–¥–Ω—è—à–Ω—è—è –¥–∞—Ç–∞: ${today}.`
      : `User's question: ${msg.text}. Today's date: ${today}.`;

  const response = await generateResponse(fullPrompt, userData, language);
  bot.sendMessage(chatId, response);
});
}

// Initialize MongoDB and Start Bot
(async () => {
  try {
    await connectToMongoDB();
    console.log("üóÑÔ∏è MongoDB is ready. Starting bot...");
    startBot();
  } catch (error) {
    console.error("‚ùå Failed to initialize bot:", error.message);
    process.exit(1);
  }
})();
